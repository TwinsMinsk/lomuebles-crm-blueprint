-- Добавляем новую таблицу для отслеживания поставок материалов
CREATE TABLE public.material_deliveries (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  material_id INTEGER NOT NULL REFERENCES public.materials(id) ON DELETE CASCADE,
  supplier_id INTEGER REFERENCES public.suppliers(supplier_id) ON DELETE SET NULL,
  order_id INTEGER REFERENCES public.orders(id) ON DELETE SET NULL,
  quantity_ordered NUMERIC(10,2) NOT NULL,
  quantity_delivered NUMERIC(10,2) DEFAULT 0,
  quantity_remaining NUMERIC(10,2) GENERATED ALWAYS AS (quantity_ordered - quantity_delivered) STORED,
  delivery_status TEXT NOT NULL DEFAULT 'Заказано' CHECK (delivery_status IN ('Заказано', 'В пути', 'Частично доставлено', 'Доставлено', 'Отменено')),
  order_date DATE NOT NULL DEFAULT CURRENT_DATE,
  expected_delivery_date DATE,
  actual_delivery_date DATE,
  tracking_number TEXT,
  delivery_address TEXT,
  unit_cost NUMERIC(10,2),
  total_cost NUMERIC(10,2) GENERATED ALWAYS AS (quantity_ordered * COALESCE(unit_cost, 0)) STORED,
  notes TEXT,
  created_by UUID NOT NULL REFERENCES auth.users(id) DEFAULT auth.uid(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Создаем индексы для оптимизации запросов
CREATE INDEX idx_material_deliveries_material_id ON public.material_deliveries(material_id);
CREATE INDEX idx_material_deliveries_supplier_id ON public.material_deliveries(supplier_id);
CREATE INDEX idx_material_deliveries_status ON public.material_deliveries(delivery_status);
CREATE INDEX idx_material_deliveries_expected_date ON public.material_deliveries(expected_delivery_date);

-- Добавляем RLS политики для таблицы поставок
ALTER TABLE public.material_deliveries ENABLE ROW LEVEL SECURITY;

-- Администраторы могут управлять всеми поставками
CREATE POLICY "Admins can manage all deliveries" ON public.material_deliveries
FOR ALL 
USING (get_current_user_role() = ANY(ARRAY['Главный Администратор'::text, 'Администратор'::text]));

-- Менеджеры могут просматривать поставки
CREATE POLICY "Managers can view deliveries" ON public.material_deliveries
FOR SELECT
USING (get_current_user_role() = 'Менеджер'::text);

-- Создаем триггер для обновления updated_at
CREATE OR REPLACE FUNCTION public.update_material_deliveries_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_material_deliveries_updated_at
BEFORE UPDATE ON public.material_deliveries
FOR EACH ROW
EXECUTE FUNCTION public.update_material_deliveries_updated_at();

-- Создаем функцию для уведомлений о просроченных поставках
CREATE OR REPLACE FUNCTION public.notify_overdue_deliveries()
RETURNS TRIGGER AS $$
DECLARE
  material_name_val TEXT;
  supplier_name_val TEXT;
  admin_user RECORD;
BEGIN
  -- Проверяем, если поставка просрочена (ожидаемая дата меньше текущей даты и статус не "Доставлено")
  IF NEW.expected_delivery_date < CURRENT_DATE AND NEW.delivery_status NOT IN ('Доставлено', 'Отменено') THEN
    
    -- Получаем название материала
    SELECT m.name INTO material_name_val
    FROM public.materials m
    WHERE m.id = NEW.material_id;
    
    -- Получаем название поставщика
    SELECT s.company_name INTO supplier_name_val
    FROM public.suppliers s
    WHERE s.supplier_id = NEW.supplier_id;
    
    -- Отправляем уведомления всем администраторам
    FOR admin_user IN 
      SELECT id, COALESCE(full_name, email, 'Администратор') as admin_name
      FROM public.profiles 
      WHERE role IN ('Главный Администратор', 'Администратор')
      AND is_active = true
    LOOP
      -- Создаем уведомление для каждого администратора
      PERFORM public.create_notification(
        admin_user.id,
        'Просроченная поставка',
        FORMAT('Поставка материала "%s" от поставщика "%s" просрочена! Ожидаемая дата: %s', 
               material_name_val, 
               COALESCE(supplier_name_val, 'Неизвестный поставщик'), 
               NEW.expected_delivery_date::text),
        'warning',
        'delivery',
        NEW.id,
        '/warehouse/deliveries'
      );
    END LOOP;
    
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

-- Создаем триггер для уведомлений о просроченных поставках
CREATE TRIGGER notify_overdue_deliveries
AFTER INSERT OR UPDATE ON public.material_deliveries
FOR EACH ROW
EXECUTE FUNCTION public.notify_overdue_deliveries();

-- Создаем функцию для автоматического создания движения материалов при доставке
CREATE OR REPLACE FUNCTION public.process_delivery_completion()
RETURNS TRIGGER AS $$
DECLARE
  delivered_quantity NUMERIC;
BEGIN
  -- Проверяем, если статус изменился на "Доставлено" и есть количество для доставки
  IF NEW.delivery_status = 'Доставлено' AND OLD.delivery_status != 'Доставлено' AND NEW.quantity_delivered > 0 THEN
    
    -- Определяем количество для поступления (разница между доставленным и уже учтенным)
    delivered_quantity = NEW.quantity_delivered - COALESCE(OLD.quantity_delivered, 0);
    
    IF delivered_quantity > 0 THEN
      -- Создаем движение материала (поступление)
      INSERT INTO public.stock_movements (
        material_id, 
        movement_type, 
        quantity, 
        unit_cost,
        supplier_id,
        movement_date, 
        notes, 
        reference_document,
        created_by
      ) VALUES (
        NEW.material_id,
        'Поступление'::public.stock_movement_type,
        delivered_quantity,
        NEW.unit_cost,
        NEW.supplier_id,
        COALESCE(NEW.actual_delivery_date, CURRENT_DATE),
        FORMAT('Автоматическое поступление по поставке #%s', NEW.id),
        COALESCE(NEW.tracking_number, 'DEL-' || NEW.id),
        NEW.created_by
      );
    END IF;
    
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp;

-- Создаем триггер для автоматического создания движений при доставке
CREATE TRIGGER process_delivery_completion
AFTER UPDATE ON public.material_deliveries
FOR EACH ROW
EXECUTE FUNCTION public.process_delivery_completion();